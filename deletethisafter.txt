
// this.fAngle = Math.atan2(forceY, forceX);
// this.force = forceLength;
//
//
// let vNewX = this.velocity * Math.cos(this.vAngle) + this.force * Math.cos(this.fAngle) * playerAccel;// - 0.1 * this.velocity * Math.cos(this.vAngle + Math.pi);
// let vNewY = this.velocity * Math.sin(this.vAngle) + this.force * Math.sin(this.fAngle) * playerAccel;// - 0.1 * this.velocity * Math.sin(this.vAngle + Math.pi);
//
//
// let vNewLength = Math.sqrt(Math.pow(vNewX, 2) + Math.pow(vNewY, 2));
// if (vNewX != 0) {
//   vNewX /= vNewLength;
// }
// if (vNewY != 0) {
//   vNewY /= vNewLength;
// }
// vNewLength = Math.sqrt(Math.pow(vNewX, 2) + Math.pow(vNewY, 2));
//
// this.vAngle = Math.atan2(vNewY, vNewX);
// if ( this.velocity < playerSpeed ) {
//   this.velocity += vNewLength;
// }
//
// this.x += this.velocity * Math.cos(this.vAngle);
// this.y += this.velocity * Math.sin(this.vAngle);







    // Math.sqrt(Math.pow(playerUFO.x - playerCow.x, 2) + Math.pow(playerUFO.y - playerCow.y, 2))
    // playerCow.x + playerUFO.d/2 + (playerUFO.x - playerCow.x) * 0.5;



    // create new obstacles
    // if (currentFrame % 60 == 0 && x == false) {
    //
    //   if (obstacleX >= (gameArea.canvas.width / 2)) {
    //     x = true;
    //   } else if (obstacleX < (gameArea.canvas.width / 2)) {
    //     x = false;
    //   }
    // }
    // else if (currentFrame % 60 == 0 && x == true){
    //   let obstacleX = Math.floor(Math.random() * ((gameArea.canvas.width - obstacleWidth) - gameArea.canvas.width / 2));
    //   gameObstacles.push(new obstacle(obstacleX, 0, obstacleWidth, 25, "white"));
    //
    //   if (obstacleX >= (gameArea.canvas.width / 2 + obstacleWidth)) {
    //     x = true;
    //   } else if (obstacleX < (gameArea.canvas.width / 2)) {
    //     x = false;
    //   }
    // }
    //






    function drawCircle(thingie) {
      let ctx = gameArea.context;
      ctx.beginPath();
      ctx.arc(thingie.x+(thingie.width / 2), thingie.y+(thingie.width / 2), (thingie.width / 2), 0, 2 * Math.PI);
      ctx.fillStyle = "white";
      ctx.fill();
    }


    // function testBeamIntersects(obstacle) {
    //   let dirX = (playerSaucer.xc - playerCow.xc) * 0.5;
    //   let dirY = (playerSaucer.yc - playerCow.yc) * 0.5;
    //   let saucerDistance = (Math.sqrt(Math.pow(playerSaucer.xc - playerCow.xc, 2) + Math.pow(playerSaucer.yc - playerCow.yc, 2)));
    //
    //
    //   let sx = playerSaucer.xc;
    //   let sy = playerSaucer.yc;
    //
    //   let cx = playerCow.xc;
    //   let cy = playerCow.yc;
    //
    //   // 1 2
    //   // 3 4
    //   let ox1 = obstacle.x;
    //   let oy1 = obstacle.y;
    //   let ox2 = obstacle.x + obstacle.width;
    //   let oy2 = obstacle.y;
    //   let ox3 = obstacle.x;
    //   let oy3 = obstacle.y + obstacle.height;
    //   let ox4 = obstacle.x + obstacle.width;
    //   let oy4 = obstacle.y + obstacle.height;
    //
    //   let i1 = testIfIntersects(sx,sy,cx,cy,ox1,oy1,ox2,oy2);
    //   let i2 = testIfIntersects(sx,sy,cx,cy,ox1,oy1,ox3,oy3);
    //   let i3 = testIfIntersects(sx,sy,cx,cy,ox2,oy2,ox4,oy4);
    //   let i4 = testIfIntersects(sx,sy,cx,cy,ox3,oy3,ox4,oy4);
    //
    //   if ( i1 || i2 || i3 || i4 ) {
    //     playerCow.beam = false;
    //   }
    //
    //
    //   let ctx = gameArea.context;
    //   ctx.strokeStyle = 'white';
    //   if ( playerCow.beam == 1 ) {
    //     ctx.strokeStyle = 'red';
    //   }
    //   ctx.lineWidth = 5;
    //   ctx.beginPath();
    //   ctx.moveTo(playerCow.x + playerCow.width/2, playerCow.y + playerCow.height/2);
    //   ctx.lineTo(playerCow.x + playerCow.width/2 + Math.cos(playerCow.dir) * 100, playerCow.y + playerCow.height/2 + Math.sin(playerCow.dir) * 100);
    //   ctx.stroke();
    // }

    // yes, i took this off of stackoverflow, don't judge me
    // function testIfIntersects(a,b,c,d,p,q,r,s) {
    //   let det, gamma, lambda;
    //   det = (c - a) * (s - q) - (r - p) * (d - b);
    //   if (det === 0) {
    //     return false;
    //   } else {
    //     lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
    //     gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
    //     return (-0.01 < lambda && lambda < 1.01) && (-0.01 < gamma && gamma < 1.01);
    //   }
    // };
